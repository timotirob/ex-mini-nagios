= S√âANCE 4 : Fiabilit√© & Tests Unitaires (Introduction √† PHPUnit)
:author: Timoth√©e Robert et les IA
:toc: left
:toc-title: Sommaire
:icons: font
:source-highlighter: highlightjs
:imagesdir: images

== Pourquoi tester ? (Le Syndrome du "F5")

Jusqu'√† pr√©sent, pour v√©rifier si votre code fonctionnait :

1. Vous √©criviez une classe.
2. Vous alliez dans `index.php`.
3. Vous rafra√Æchissiez votre navigateur (F5).
4. Vous regardiez si "√ßa avait l'air bon".

=== Le probl√®me
Imaginez que vous modifiez la classe `Validator` pour am√©liorer la regex des IP.

* √ätes-vous s√ªr que cela n'a pas cass√© la validation des Hostnames ?
* Allez-vous retester manuellement **tous** les cas possibles (IP vide, IP locale, IP avec des lettres...) √† chaque modification ?

**La r√©ponse est non.** Et c'est l√† que les bugs apparaissent en production.

=== La solution : Les Tests Unitaires
Un test unitaire est un petit bout de code qui :

1. Instancie une de vos classes.
2. Ex√©cute une m√©thode.
3. Compare le r√©sultat obtenu avec le r√©sultat attendu (**Assertion**).

Si le r√©sultat est diff√©rent : **C'est Rouge (√âchec)**.
Si c'est identique : **C'est Vert (Succ√®s)**.

.Le Cycle TDD (Test Driven Development)
[mermaid]
....
graph LR
    A((Rouge)) -->|J'√©cris le code| B((Vert))
    B -->|J'am√©liore| C((Refactoring))
    C -->|Je v√©rifie| B
    style A fill:#f00,stroke:#333,stroke-width:2px,color:white
    style B fill:#0f0,stroke:#333,stroke-width:2px
    style C fill:#00f,stroke:#333,stroke-width:2px,color:white
....

== Installation de l'environnement de Test

Nous allons utiliser **PHPUnit**, le standard industriel pour tester en PHP.

=== Installation via Composer
Ouvrez votre terminal √† la racine du projet `MiniNagios` et lancez :

[source,bash]
----
composer require --dev phpunit/phpunit
----

[NOTE]
====
**Pourquoi `--dev` ?**
Les outils de tests ne servent que pendant le d√©veloppement. Ils ne doivent pas √™tre install√©s sur le serveur de production du client. Composer s√©pare les deux environnements.
====

=== Configuration de PHPUnit
Cr√©ez un fichier nomm√© `phpunit.xml` √† la racine du projet. C'est le fichier qui explique √† PHPUnit comment travailler.

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<phpunit bootstrap="vendor/autoload.php" colors="true">
    <testsuites>
        <testsuite name="MiniNagios Test Suite">
            <directory>tests</directory>
        </testsuite>
    </testsuites>
</phpunit>
----

=== Pr√©paration du dossier
1. Cr√©ez un dossier `tests` √† la racine du projet (au m√™me niveau que `src` et `public`).
2. Nous allons dire √† Composer o√π trouver nos classes de test. Ouvrez `composer.json` et ajoutez la section `autoload-dev` :

[source,json]
----
{
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Tests\\": "tests/"
        }
    },
    "require-dev": {
        "phpunit/phpunit": "^10.0"
    }
}
----
*(Attention √† la virgule apr√®s le premier bloc autoload !)*

3. Mettez √† jour l'autoloader :
[source,bash]
----
composer dump-autoload
----

== Notre Premier Test : Le Validator

La classe `Validator` (S√©ance 2) est parfaite pour commencer car elle est **statique** et pure (pas d'√©tat interne).

=== √âcriture du Test
Cr√©ez le fichier `tests/ValidatorTest.php`.

[source,php]
----
<?php
namespace Tests;

use PHPUnit\Framework\TestCase;
use App\Validator;

class ValidatorTest extends TestCase
{
    // Un test doit toujours commencer par le mot "test"
    public function testIpValide()
    {
        // Sc√©nario : Je donne une IP correcte
        $resultat = Validator::isIpValid("192.168.1.1");

        // Assertion : Je m'attends √† ce que ce soit VRAI (True)
        $this->assertTrue($resultat, "192.168.1.1 devrait √™tre valide");
    }

    public function testIpInvalide()
    {
        // Sc√©nario : Je donne n'importe quoi
        $resultat = Validator::isIpValid("Patate");

        // Assertion : Je m'attends √† ce que ce soit FAUX (False)
        $this->assertFalse($resultat, "Patate ne devrait pas √™tre une IP valide");
    }

    public function testIpVide()
    {
        $this->assertFalse(Validator::isIpValid(""), "Une IP vide doit √©chouer");
    }
}
----

=== Lancement des Tests
Dans votre terminal, lancez la commande magique :

[source,bash]
----
./vendor/bin/phpunit
----

**R√©sultat attendu :**
Vous devriez voir une barre verte (ou des points `.`) et le message : `OK (3 tests, 3 assertions)`.

[TIP]
.√áa ne marche pas ?
====
Si vous avez une erreur rouge, lisez le message ! Souvent, c'est une erreur de namespace ou de nom de fichier. Assurez-vous d'avoir fait le `composer dump-autoload`.
====

== Tester la Logique Objet : Les Services

Maintenant, testons quelque chose de plus complexe : la classe `Service` (S√©ance 3). Ici, nous allons tester l'√©tat de l'objet (State Testing).

=== Cr√©ation de `tests/ServiceTest.php`

[source,php]
----
<?php
namespace Tests;

use PHPUnit\Framework\TestCase;
use App\Service;

class ServiceTest extends TestCase
{
    public function testCreationService()
    {
        // 1. Arrange (Pr√©paration)
        $service = new Service("Apache", 80);

        // 2. Act (Action) & 3. Assert (V√©rification)
        // V√©rifions que le service est √©teint par d√©faut
        $this->assertFalse($service->estDemarre());
    }

    public function testDemarrageEtArret()
    {
        $service = new Service("MySQL", 3306);

        // On d√©marre
        $service->demarrer();
        $this->assertTrue($service->estDemarre(), "Le service devrait √™tre d√©marr√©");

        // On arr√™te
        $service->arreter();
        $this->assertFalse($service->estDemarre(), "Le service devrait √™tre arr√™t√©");
    }

    public function testPortInvalideLanceException()
    {
        // Ici, on teste que notre code PLANTE correctement quand on l'attaque
        $this->expectException(\Exception::class);
        $this->expectExceptionMessage("invalide");

        // Cette ligne doit provoquer l'exception
        new Service("BadService", 999999);
    }
}
----

Lancez √† nouveau `./vendor/bin/phpunit`. Vous devriez avoir 6 tests valid√©s !

== Le Challenge TDD (Test Driven Development)

Pour cet exercice, nous allons inverser les r√¥les.
**Nous avons une nouvelle demande client, mais nous allons d'abord √©crire le test avant d'√©crire le code.**

**Demande :** Nous voulons pouvoir mettre un `Serveur` en "Mode Maintenance".

* Par d√©faut, un serveur n'est PAS en maintenance.
* Si on appelle `activerMaintenance()`, il passe en maintenance.
* Si un serveur est en maintenance, `afficherStatut()` doit commencer par "üöß [MAINTENANCE] üöß".

=== √âtape 1 : Le Test (Qui va √©chouer)
Cr√©ez `tests/ServeurTest.php`.

[source,php]
----
<?php
namespace Tests;

use PHPUnit\Framework\TestCase;
use App\Serveur;

class ServeurTest extends TestCase
{
    public function testModeMaintenance()
    {
        $srv = new Serveur("Test-Srv", "10.0.0.1", "Linux");

        // 1. V√©rif par d√©faut
        $this->assertFalse($srv->enMaintenance());

        // 2. On active
        $srv->activerMaintenance();
        $this->assertTrue($srv->enMaintenance());

        // 3. On v√©rifie l'affichage
        // La fonction str_contains v√©rifie si le texte contient la balise
        $this->assertStringContainsString("üöß", $srv->afficherStatut());
    }
}
----

Lancez `phpunit`. **CRASH !** üõë
`Error: Call to undefined method App\Serveur::enMaintenance()`.
C'est normal, la m√©thode n'existe pas.

=== √âtape 2 : Le Code (Qui va faire passer le test)
√Ä vous de jouer ! Modifiez `src/Serveur.php` pour que le test passe au vert.

1. Ajoutez une propri√©t√© `private bool $maintenance = false;`.
2. Cr√©ez la m√©thode `enMaintenance(): bool`.
3. Cr√©ez la m√©thode `activerMaintenance(): void`.
4. Modifiez `afficherStatut()` pour ajouter le petit logo chantier si n√©cessaire.

Relancez `phpunit` jusqu'√† voir la barre **VERTE**.

== Exercices Pratiques (TP)

√Ä vous d'√©crire les tests pour s√©curiser le reste de l'application.

=== Exercice 1 : Tester le Validator de Hostname (15 min)
Dans `ValidatorTest.php`, ajoutez une m√©thode `testHostnameValide()`.
Elle doit v√©rifier que :

* "SRV-WEB-01" est **vrai**.
* "srv-web" est **vrai**.
* "SRV WEB" (espace) est **faux**.
* "SRV_WEB" (underscore) est **faux** (selon votre regex de la s√©ance 2).

=== Exercice 2 : Tester la Composition (20 min)
Dans `ServeurTest.php`, √©crivez un test `testAjoutService()`.
Sc√©nario :

1. Cr√©er un Serveur.
2. Cr√©er un Service.
3. Ajouter le service au serveur.
4. *Astuce :* Pour v√©rifier que √ßa a march√©, vous devrez peut-√™tre ajouter une m√©thode `getNbServices()` dans la classe Serveur (temporairement ou d√©finitivement) et faire un `$this->assertEquals(1, $srv->getNbServices())`.

=== Exercice 3 : Tester la Criticit√© (20 min)
Reprenez la logique de l'exercice "Intelligence Collective" de la S√©ance 3 (Service Critique + √âteint = DANGER).
√âcrivez un test `testAlerteRougeSiServiceCritiqueEteint()` :

1. Cr√©ez un Serveur.
2. Cr√©ez un Service critique (`true`) mais ne le d√©marrez pas.
3. Ajoutez-le au serveur.
4. V√©rifiez que `verifierSante()` retourne bien une cha√Æne contenant "DANGER".

